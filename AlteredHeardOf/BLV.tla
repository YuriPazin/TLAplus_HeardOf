--------------------------------------- MODULE BLV ---------------------------------------
EXTENDS Naturals, FiniteSets

(****************************************************************************)
(* This algorithm is called BLV. (Byzantine Last Voting). It is based on    *)
(* the last voting mechanism introduced in the Paxos algorithm by Lamport   *) 
(* for benign faults. This mechanism is also at the core of the PBFT        *)
(* algorithm by Castro and Liskov.                                          *)
(*                                                                          *)
(* A brief, simplified explanation of the Last Voting mechanism: each       *)
(* process store its current voting intention (vote) along with a           *) 
(* timestamp (ts) that shows when the vote was last updated. If enough      *)
(* processes vote for the same value with the same timestamp, then a final  *)
(* decision can be reached. This ensues no decision is made based on        *) 
(* outdated information.                                                    *)
(****************************************************************************)

Phases == 3     \* The number of phases of the algorithm

\*  INITIAL STATES 
\*      Init(P,V) == set of all possible initial states
\*      initp(v)  == initial state with value "v"

Init(P,V) == LET initp(v) == [ vote    |-> v         ,
                               ts      |-> 0         , 
                               history |-> {<<v,0>>} ]
                               
             IN [ P -> { initp(v) : v \in V } ] 

\*
\* For P = (p1,p2,p3) and V = (A,B) we would have a set of 2 possible initial 
\* states per process: initp(A) and initp(B) generated by the expression:
\* 
\*   {initp(v): v \in V} == { [ vote|-> A , ts|-> 0 , history|-> {<<A,0>>} ] ,
\*                            [ vote|-> B , ts|-> 0 , history|-> {<<B,0>>} ] }
\* 
\* The expression Init(P,V) enumerates all possible functions that maps "P" to 
\* those initial process states, in this case, we would have a set of 8 possible
\* intial system states:
\* 
\*  Init(P,V) == {  [ p1 |-> initp(A) , p2|-> initp(A) , p3|-> initp(A) ] ,
\*                  [ p1 |-> initp(A) , p2|-> initp(A) , p3|-> initp(B) ] ,
\*                  [ p1 |-> initp(A) , p2|-> initp(B) , p3|-> initp(A) ] ,
\*                  [ p1 |-> initp(A) , p2|-> initp(B) , p3|-> initp(B) ] ,
\*                  [ p1 |-> initp(B) , p2|-> initp(A) , p3|-> initp(A) ] ,
\*                  [ p1 |-> initp(B) , p2|-> initp(A) , p3|-> initp(B) ] ,
\*                  [ p1 |-> initp(B) , p2|-> initp(B) , p3|-> initp(A) ] ,
\*                  [ p1 |-> initp(B) , p2|-> initp(B) , p3|-> initp(B) ] }
\*

\* MESSAGE SENDING FUNCTION "S"

S(s,r) ==  CASE r = 0 -> [v       |-> s.vote   ,
                          ts      |-> s.ts     , 
                          history |-> s.history]
           \*TODO:               
           []   r = 1 -> [v       |-> {<<v,ts>> \in s.history: ts = r} ]
           \*TODO:
           []   r = 2 -> [v       |-> IF   s.ts = r
                                      THEN s.vote 
                                      ELSE {}       ]

           
min(Set) == CHOOSE x \in Set:         \* Smallest element of a set,  
                \A y \in Set: x <= y  \* used in FBLVT expression.

FBLVT(s,r,M) == LET possibleV  == TRUE \*TODO
                    confirmedV == TRUE \*TODO
                IN  IF   Cardinality(confirmedV) >= 1
                    THEN min(confirmedV)
                    ELSE IF   TRUE \*TODO
                         THEN TRUE \*TODO
                         ELSE {} 
                    
\*  STATE TRANSITION FUNCTION "T"
                
T(s,r,M) ==

    CASE r = 0 -> [vote    |-> s.vote     ,
                   ts      |-> s.ts       , 
                   history |-> LET select == FBLVT(s,r,M) 
                               IN  IF   select # {}
                                   THEN s.history \cup {{select,0}}             
                                   ELSE s.history]
    \*TODO:                                        
    []   r = 1 -> [vote    |-> s.vote       , 
                   ts      |-> s.ts         , 
                   history |-> s.history    ]
    \*TODO:               
    []   r = 2 -> [vote    |-> s.vote       ,
                   ts      |-> s.ts         , 
                   history |-> s.history    ]

\*TODO:                 
ValidMessages == TRUE
                                      
==========================================================================================
